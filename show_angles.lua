--local variables for API. Automatically generated by https://github.com/simpleavaster/gslua/blob/master/authors/sapphyrus/generate_api.lua 
local client_latency, client_log, client_draw_rectangle, client_draw_circle_outline, client_userid_to_entindex, client_draw_indicator, client_draw_gradient, client_set_event_callback, client_screen_size, client_eye_position = client.latency, client.log, client.draw_rectangle, client.draw_circle_outline, client.userid_to_entindex, client.draw_indicator, client.draw_gradient, client.set_event_callback, client.screen_size, client.eye_position 
local client_draw_circle, client_color_log, client_delay_call, client_draw_text, client_visible, client_exec, client_trace_line, client_set_cvar = client.draw_circle, client.color_log, client.delay_call, client.draw_text, client.visible, client.exec, client.trace_line, client.set_cvar 
local client_world_to_screen, client_draw_hitboxes, client_get_cvar, client_draw_line, client_camera_angles, client_draw_debug_text, client_random_int, client_random_float = client.world_to_screen, client.draw_hitboxes, client.get_cvar, client.draw_line, client.camera_angles, client.draw_debug_text, client.random_int, client.random_float 
local entity_get_local_player, entity_is_enemy, entity_hitbox_position, entity_get_player_name, entity_get_steam64, entity_get_bounding_box, entity_get_all, entity_set_prop = entity.get_local_player, entity.is_enemy, entity.hitbox_position, entity.get_player_name, entity.get_steam64, entity.get_bounding_box, entity.get_all, entity.set_prop 
local entity_is_alive, entity_get_player_weapon, entity_get_prop, entity_get_players, entity_get_classname = entity.is_alive, entity.get_player_weapon, entity.get_prop, entity.get_players, entity.get_classname 
local globals_realtime, globals_absoluteframetime, globals_tickcount, globals_curtime, globals_mapname, globals_tickinterval, globals_framecount, globals_frametime, globals_maxplayers = globals.realtime, globals.absoluteframetime, globals.tickcount, globals.curtime, globals.mapname, globals.tickinterval, globals.framecount, globals.frametime, globals.maxplayers 
local ui_new_slider, ui_new_combobox, ui_reference, ui_set_visible, ui_is_menu_open, ui_new_color_picker, ui_set_callback, ui_set, ui_new_checkbox, ui_new_hotkey, ui_new_button, ui_new_multiselect, ui_get = ui.new_slider, ui.new_combobox, ui.reference, ui.set_visible, ui.is_menu_open, ui.new_color_picker, ui.set_callback, ui.set, ui.new_checkbox, ui.new_hotkey, ui.new_button, ui.new_multiselect, ui.get 
local math_ceil, math_tan, math_log10, math_randomseed, math_cos, math_sinh, math_random, math_huge, math_pi, math_max, math_atan2, math_ldexp, math_floor, math_sqrt, math_deg, math_atan, math_fmod = math.ceil, math.tan, math.log10, math.randomseed, math.cos, math.sinh, math.random, math.huge, math.pi, math.max, math.atan2, math.ldexp, math.floor, math.sqrt, math.deg, math.atan, math.fmod 
local math_acos, math_pow, math_abs, math_min, math_sin, math_frexp, math_log, math_tanh, math_exp, math_modf, math_cosh, math_asin, math_rad = math.acos, math.pow, math.abs, math.min, math.sin, math.frexp, math.log, math.tanh, math.exp, math.modf, math.cosh, math.asin, math.rad 
local table_maxn, table_foreach, table_sort, table_remove, table_foreachi, table_move, table_getn, table_concat, table_insert = table.maxn, table.foreach, table.sort, table.remove, table.foreachi, table.move, table.getn, table.concat, table.insert 
local string_find, string_format, string_rep, string_gsub, string_len, string_gmatch, string_dump, string_match, string_reverse, string_byte, string_char, string_upper, string_lower, string_sub = string.find, string.format, string.rep, string.gsub, string.len, string.gmatch, string.dump, string.match, string.reverse, string.byte, string.char, string.upper, string.lower, string.sub 
--end of local variables 

local circle_radius_2d = 32
local circle_width_percentage_2d = 0.08
local outline = true

local show_angles_reference = ui.new_multiselect("VISUALS", "Other ESP", "Show Anti-aimbot angles", {"Real", "Fake", "LBY", "Camera"})
local style_firstperson_reference = ui.new_combobox("VISUALS", "Other ESP", "Style (first person)", {"Off", "Lines", "Circle", "Arrows (Rounded)", "Arrows (Style 2)"})
local style_thirdperson_reference = ui.new_combobox("VISUALS", "Other ESP", "Style (third person)", {"Off", "Lines", "Circle"})

local real_length_reference = ui.new_slider("VISUALS", "Other ESP", "Real Distance / Color", 10, 80, 30, true, "u")
local real_color_reference = ui.new_color_picker("VISUALS", "Other ESP", "Real Color", 28, 132, 255, 220)

local fake_length_reference = ui.new_slider("VISUALS", "Other ESP", "Fake Distance / Color", 10, 80, 30, true, "u")
local fake_color_reference = ui.new_color_picker("VISUALS", "Other ESP", "Fake Color", 0, 164, 52, 220)

local lby_length_reference = ui.new_slider("VISUALS", "Other ESP", "LBY Distance / Color", 10, 80, 30, true, "u")
local lby_color_reference = ui.new_color_picker("VISUALS", "Other ESP", "LBY Color", 255, 0, 0, 220)

local camera_length_reference = ui.new_slider("VISUALS", "Other ESP", "Camera Distance / Color", 10, 80, 30, true, "u")
local camera_color_reference = ui.new_color_picker("VISUALS", "Other ESP", "Camera Color", 255, 255, 255, 220)

local function is_thirdperson(ctx)
	local x, y, z = client_eye_position()
	local pitch, yaw = client_camera_angles()
	
	yaw = yaw - 180
	pitch, yaw = math_rad(pitch), math_rad(yaw)

	x = x + math_cos(yaw)*4
	y = y + math_sin(yaw)*4
	z = z + math_sin(pitch)*4

	local wx, wy = client_world_to_screen(ctx, x, y, z)
	return wx ~= nil
end

local function contains(table, val)
	for i=1, #table do
		if table[i] == val then 
			return true
		end
	end
	return false
end


local function rotate_point(x, y, x_center, y_center, rotation)
	if rotation == 0 then
		return x, y
	end
	
	local rotation = math_rad(rotation)
	local sin, cos = math_sin(rotation), math_cos(rotation)

	local x_new = cos * (x - x_center) - sin * (y - y_center) + x_center
	local y_new = sin * (x - x_center) + cos * (y - y_center) + y_center

	return x_new, y_new
end

--local function draw_triangle_outline(ctx, x, y, size, rotation)
--	local x_o, y_o = x + size, y + size
--	x_o, y_o = rotate_point(x_o, y_o, x, y, rotation)

--	local x1, y1 = rotate_point(x_o, y_o, x, y, 0)
--	local x2, y2 = rotate_point(x_o, y_o, x, y, 120)
--	local x3, y3 = rotate_point(x_o, y_o, x, y, 240)
	
--	client_draw_line(ctx, x1, y1, x2, y2, 255, 255, 255, 200)
--	client_draw_line(ctx, x2, y2, x3, y3, 255, 255, 255, 200)
--	client_draw_line(ctx, x3, y3, x1, y1, 255, 255, 255, 200)
--end

local function draw_circle_3d(ctx, x, y, z, radius, r, g, b, a, accuracy, width, outline, start_degrees, percentage)
	local accuracy = accuracy or 3
	local width = width or 1
	local outline = outline or false
	local start_degrees = start_degrees ~= nil and start_degrees or 0
	local percentage = percentage ~= nil and percentage or 1

	local screen_x_line_old, screen_y_line_old
	for rot=start_degrees, start_degrees+percentage*360, accuracy do
		local rot_temp = math_rad(rot)
		local lineX, lineY, lineZ = radius * math_cos(rot_temp) + x, radius * math_sin(rot_temp) + y, z
		local screen_x_line, screen_y_line = client_world_to_screen(ctx, lineX, lineY, lineZ)
		if rot == start_degrees then
			screen_x_line_old, screen_y_line_old = screen_x_line, screen_y_line
		end
		if screen_x_line ~=nil and screen_x_line_old ~= nil then
			for i=1, width do
				local i=i-1
				client_draw_line(ctx, screen_x_line, screen_y_line-i, screen_x_line_old, screen_y_line_old-i, r, g, b, a)
			end
			if outline then
				local outline_a = a/255*160
				client_draw_line(ctx, screen_x_line, screen_y_line-width, screen_x_line_old, screen_y_line_old-width, 16, 16, 16, outline_a)
				client_draw_line(ctx, screen_x_line, screen_y_line+1, screen_x_line_old, screen_y_line_old+1, 16, 16, 16, outline_a)
			end
		end
		screen_x_line_old, screen_y_line_old = screen_x_line, screen_y_line
	end
end

local function draw_angle(ctx, name, distance, location_x, location_y, location_z, origin_x, origin_y, yaw, style, thirdperson, base_yaw, outline, r, g, b, a)
	if thirdperson then
		if style == "Lines" then
			local location_x_angle = location_x + math_cos(math_rad(yaw)) * distance
			local location_y_angle = location_y + math_sin(math_rad(yaw)) * distance

			local world_x, world_y = client_world_to_screen(ctx, location_x_angle, location_y_angle, location_z)

			if world_x ~= nil then
				if outline then
					client_draw_line(ctx, origin_x-1, origin_y, world_x-1, world_y, 16, 16, 16, 220)
					client_draw_line(ctx, origin_x+1, origin_y, world_x+1, world_y, 16, 16, 16, 220)
					client_draw_line(ctx, origin_x, origin_y-1, world_x, world_y-1, 16, 16, 16, 220)
					client_draw_line(ctx, origin_x, origin_y+1, world_x, world_y+1, 16, 16, 16, 220)
				end
				client_draw_line(ctx, origin_x, origin_y, world_x, world_y, r, g, b, a)
				client_draw_text(ctx, world_x, world_y, r, g, b, a, "c-", 0, name)
			end
		elseif style == "Circle" then
			local circle_width_percentage = 0.06
			draw_circle_3d(ctx, location_x, location_y, location_z, 20, r, g, b, a, 2.5, 2, false, yaw-(circle_width_percentage*360/2), circle_width_percentage)
		end
	else
		local screen_width, screen_height = client_screen_size()
		local screen_center_x, screen_center_y = screen_width/2, screen_height/2

		yaw = base_yaw - yaw
		yaw = yaw - 90

		local start_x = screen_center_x + math_cos(math_rad(yaw)) * 8
		local start_y = screen_center_y + math_sin(math_rad(yaw)) * 8

		if style == "Lines" then
			local distance = distance * 1.6
			local x_angle = start_x + math_cos(math_rad(yaw)) * distance
			local y_angle = screen_center_y + math_sin(math_rad(yaw)) * distance
			if outline then
				client_draw_line(ctx, start_x-1, start_y, x_angle-1, y_angle, 16, 16, 16, 220)
				client_draw_line(ctx, start_x+1, start_y, x_angle+1, y_angle, 16, 16, 16, 220)
				client_draw_line(ctx, start_x, start_y-1, x_angle, y_angle-1, 16, 16, 16, 220)
				client_draw_line(ctx, start_x, start_y+1, x_angle, y_angle+1, 16, 16, 16, 220)
			end
			client_draw_line(ctx, start_x, start_y, x_angle, y_angle, r, g, b, a)
			client_draw_text(ctx, x_angle, y_angle, r, g, b, a, "c-", 0, name)
		elseif style == "Circle" then
			local circle_width_percentage_2d = circle_width_percentage_2d * (distance / 30)
			client_draw_circle_outline(ctx, screen_center_x, screen_center_y, r, g, b, a, circle_radius_2d, yaw-(circle_width_percentage_2d*360/2), circle_width_percentage_2d, 3)
		elseif style == "Arrows (Rounded)" then
			local percentage = 0.18
			local radius = 25
			local distance = distance * 2
			local x_angle = screen_center_x + math_cos(math_rad(yaw)) * distance
			local y_angle = screen_center_y + math_sin(math_rad(yaw)) * distance

			local start_degrees = yaw-(360*0.08)-180

			if outline then
				client_draw_circle(ctx, x_angle-1, y_angle, 16, 16, 16, 200, radius, start_degrees, percentage)
				client_draw_circle(ctx, x_angle+1, y_angle, 16, 16, 16, 200, radius, start_degrees, percentage)
				client_draw_circle(ctx, x_angle, y_angle-1, 16, 16, 16, 200, radius, start_degrees, percentage)
				client_draw_circle(ctx, x_angle, y_angle+1, 16, 16, 16, 200, radius, start_degrees, percentage)
			end

			client_draw_circle(ctx, x_angle, y_angle, r, g, b, a, radius, start_degrees, percentage)

			--make line sharper (doesn't work properly)
			--for additional=-1, -1 do
				--local x1 = x_angle + math_cos(math_rad(start_degrees)) * (radius+additional)
				--local y1 = y_angle + math_sin(math_rad(start_degrees)) * (radius+additional)

				--local x2 = x_angle + math_cos(math_rad(start_degrees+(360*0.15))) * (radius+additional)
				--local y2 = y_angle + math_sin(math_rad(start_degrees+(360*0.15))) * (radius+additional)
				
			--	local x3 = x_angle + math_cos(math_rad(start_degrees+(360*0.15*0.5))) * (radius+additional)
			--	local y3 = y_angle + math_sin(math_rad(start_degrees+(360*0.15*0.5))) * (radius+additional)

				--client_draw_rectangle(ctx, x2-5, y2-5, 10, 10, 255, 255, 255, 255)
				--client_draw_line(ctx, x1, y1, x2, y2, r, g, b, a)

			--	local sharper_percentage = 0.1
			--	client_draw_circle(ctx, x3, y3, r, g, b, a, 11, start_degrees-90+20, sharper_percentage)
			--	client_draw_circle(ctx, x3, y3, r, g, b, a, 11, start_degrees+90+(sharper_percentage*0.1), sharper_percentage)
				
			--end
		elseif style == "Arrows (Style 2)" then
			distance = distance*0.6

			-- Arrow Main
			local x1 = start_x + math_cos(math_rad(yaw-5)) * (distance * 2)
			local y1 = start_y + math_sin(math_rad(yaw-5)) * (distance * 2)
			-- Arrow Main
			local x2 = start_x + math_cos(math_rad(yaw+5)) * (distance * 2)
			local y2 = start_y + math_sin(math_rad(yaw+5)) * (distance * 2)
			-- Arrow Middle
			local x3 = start_x + math_cos(math_rad(yaw)) * ((distance + distance / 5) * 2)
			local y3 = start_y + math_sin(math_rad(yaw)) * ((distance + distance / 5) * 2)
			-- Arrow Outside
			local x4 = start_x + math_cos(math_rad(yaw+15)) * ((distance - 1) * 2)
			local y4 = start_y + math_sin(math_rad(yaw+15)) * ((distance - 1) * 2)
			-- Arrow Outside
			local x5 = start_x + math_cos(math_rad(yaw-15)) * ((distance - 1) * 2)
			local y5 = start_y + math_sin(math_rad(yaw-15)) * ((distance - 1) * 2)

			client_draw_line(ctx, start_x, start_y, x1, y1, r, g, b, a)
			client_draw_line(ctx, start_x, start_y, x2, y2, r, g, b, a)
			client_draw_line(ctx, x3, y3, x4, y4, r, g, b, a)
			client_draw_line(ctx, x3, y3, x5, y5, r, g, b, a)
			client_draw_line(ctx, x2, y2, x4, y4, r, g, b, a)
			client_draw_line(ctx, x1, y1, x5, y5, r, g, b, a)
		end
	end
end

local function on_show_angles_change()
	local value = ui_get(show_angles_reference)
	ui_set_visible(real_length_reference, contains(value, "Real"))
	ui_set_visible(real_color_reference, contains(value, "Real"))

	ui_set_visible(fake_length_reference, contains(value, "Fake"))
	ui_set_visible(fake_color_reference, contains(value, "Fake"))

	ui_set_visible(lby_length_reference, contains(value, "LBY"))
	ui_set_visible(lby_color_reference, contains(value, "LBY"))

	ui_set_visible(camera_length_reference, contains(value, "Camera"))
	ui_set_visible(camera_color_reference, contains(value, "Camera"))

	ui_set_visible(style_firstperson_reference, #value > 0)
	ui_set_visible(style_thirdperson_reference, #value > 0)
end
on_show_angles_change()
ui.set_callback(show_angles_reference, on_show_angles_change)

local function on_paint(ctx)
	local value = ui_get(show_angles_reference)
	if #value == 0 then
		return
	end

	local thirdperson = is_thirdperson(ctx)
	local style = thirdperson and ui_get(style_thirdperson_reference) or ui_get(style_firstperson_reference)
	if style == "Off" then
		return
	end

	local local_player = entity_get_local_player()
	if local_player == nil or not entity_is_alive(local_player) then
		return
	end

	local location_x, location_y, location_z = entity_get_prop(local_player, "m_vecAbsOrigin")
	location_z = location_z + 1

	local _, base_yaw = client_camera_angles()

	local screen_width, screen_height = client_screen_size()
	local screen_center_x, screen_center_y = screen_width/2, screen_height/2

	if location_x ~= nil then
		local world_x, world_y = client_world_to_screen(ctx, location_x, location_y, location_z)
		if thirdperson then
			if world_x == nil then
				return
			end
			
			if style == "Circle" then
				draw_circle_3d(ctx, location_x, location_y, location_z, 20, 17, 17, 17, 90, 2.5, 2)
			end
		else
			if style == "Circle" then
				client_draw_circle_outline(ctx, screen_center_x, screen_center_y, 17, 17, 17, 190, circle_radius_2d+1, 0, 1, 5)
				client_draw_circle_outline(ctx, screen_center_x, screen_center_y, 17, 17, 17, 200, circle_radius_2d+1, 0, 1, 1)
				client_draw_circle_outline(ctx, screen_center_x, screen_center_y, 17, 17, 17, 200, circle_radius_2d-3, 0, 1, 1)
			end
		end

		--draw real
		if contains(value, "Real") then
			local _, yaw = entity_get_prop(local_player, "m_angAbsRotation")
			if yaw ~= nil then
				local bodyyaw = entity_get_prop(local_player, "m_flPoseParameter", 11)
				if bodyyaw ~= nil then
					bodyyaw = bodyyaw * 120 - 60
					draw_angle(ctx, "REAL", ui_get(real_length_reference), location_x, location_y, location_z, world_x, world_y, yaw + bodyyaw, style, thirdperson, base_yaw, outline, ui_get(real_color_reference))
				end
			end
		end

		--draw fake
		if contains(value, "Fake") then
			local _, yaw, _ = entity_get_prop(entity_get_local_player(), "m_angEyeAngles")

			draw_angle(ctx, "FAKE", ui_get(fake_length_reference), location_x, location_y, location_z, world_x, world_y, yaw, style, thirdperson, base_yaw, outline, ui_get(fake_color_reference))
		end

		--draw lby
		if contains(value, "LBY") then
			local yaw = entity_get_prop(entity_get_local_player(), "m_flLowerBodyYawTarget")

			draw_angle(ctx, "LBY", ui_get(lby_length_reference), location_x, location_y, location_z, world_x, world_y, yaw, style, thirdperson, base_yaw, outline, ui_get(lby_color_reference))
		end

		--draw camera
		if contains(value, "Camera") then
			local yaw = base_yaw

			draw_angle(ctx, "CAM", ui_get(camera_length_reference), location_x, location_y, location_z, world_x, world_y, yaw, style, thirdperson, base_yaw, outline, ui_get(camera_color_reference))
		end

		if thirdperson then
			if style == "Lines" then
				client_draw_circle(ctx, world_x, world_y, 17, 17, 17, 255, 2, 0, 1)
			end
		else
		end
	end
end
client.set_event_callback("paint", on_paint)
